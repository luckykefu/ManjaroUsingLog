#!/usr/bin/env python3
"""
PATH ç¯å¢ƒå˜é‡ç®¡ç†å·¥å…·
æ”¯æŒåœ¨ shell é…ç½®æ–‡ä»¶ä¸­æ·»åŠ /ç§»é™¤è·¯å¾„
"""

import os
import sys
import argparse
from pathlib import Path
from typing import List, Optional, Tuple

class PathManager:
    """PATH ç¯å¢ƒå˜é‡ç®¡ç†å™¨"""
    
    def __init__(self, config_file: Optional[str] = None):
        """
        åˆå§‹åŒ–è·¯å¾„ç®¡ç†å™¨
        
        Args:
            config_file: é…ç½®æ–‡ä»¶è·¯å¾„ï¼Œå¦‚æœä¸º None åˆ™è‡ªåŠ¨æ£€æµ‹
        """
        self.config_file = self._detect_config_file(config_file)
        self.shell_name = self._get_shell_name()
    
    def _detect_config_file(self, config_file: Optional[str]) -> str:
        """æ£€æµ‹ shell é…ç½®æ–‡ä»¶"""
        if config_file:
            return os.path.expanduser(config_file)
        
        # è‡ªåŠ¨æ£€æµ‹å½“å‰ä½¿ç”¨çš„ shell
        shell = os.environ.get('SHELL', '')
        home = Path.home()
        
        config_files = [
            f"{home}/.zshrc",      # zsh
            f"{home}/.bashrc",     # bash
            f"{home}/.bash_profile", # bash (macOS)
            f"{home}/.profile",    # é€šç”¨
            f"{home}/.config/fish/config.fish"  # fish
        ]
        
        # æ ¹æ®å½“å‰ shell ä¼˜å…ˆé€‰æ‹©
        if 'zsh' in shell:
            config_files.insert(0, f"{home}/.zshrc")
        elif 'bash' in shell:
            config_files.insert(0, f"{home}/.bashrc")
        elif 'fish' in shell:
            config_files.insert(0, f"{home}/.config/fish/config.fish")
        
        # è¿”å›ç¬¬ä¸€ä¸ªå­˜åœ¨çš„é…ç½®æ–‡ä»¶
        for config in config_files:
            if os.path.exists(config):
                return config
        
        # å¦‚æœéƒ½ä¸å­˜åœ¨ï¼Œä½¿ç”¨ zshrc
        return f"{home}/.zshrc"
    
    def _get_shell_name(self) -> str:
        """è·å– shell åç§°"""
        config_name = os.path.basename(self.config_file)
        if 'zsh' in config_name:
            return 'zsh'
        elif 'bash' in config_name:
            return 'bash'
        elif 'fish' in config_name:
            return 'fish'
        else:
            return 'shell'
    
    def _normalize_path(self, path: str) -> str:
        """æ ‡å‡†åŒ–è·¯å¾„"""
        path = os.path.expanduser(path)
        path = os.path.abspath(path)
        return path.rstrip('/')
    
    def _get_export_patterns(self, path: str) -> List[str]:
        """è·å–è·¯å¾„å¯¼å‡ºæ¨¡å¼"""
        if self.shell == 'fish':
            return [
                f'set -gx PATH "{path}" $PATH',
                f'set -gx PATH $PATH "{path}"'
            ]
        else:
            return [
                f'export PATH="{path}:$PATH"',
                f'export PATH="$PATH:{path}"',
                f"export PATH='{path}:$PATH'",
                f"export PATH='$PATH:{path}'",
                f'export PATH="{path}:$PATH" # Added by path manager',
                f'export PATH="$PATH:{path}" # Added by path manager'
            ]
    
    def _create_config_if_not_exists(self):
        """å¦‚æœé…ç½®æ–‡ä»¶ä¸å­˜åœ¨åˆ™åˆ›å»º"""
        config_path = Path(self.config_file)
        config_path.parent.mkdir(parents=True, exist_ok=True)
        
        if not config_path.exists():
            with open(config_path, 'w', encoding='utf-8') as f:
                f.write(f"# {self.shell_name} configuration file\n")
                f.write(f"# Generated by path manager\n\n")
            print(f"ğŸ“ åˆ›å»ºæ–°çš„é…ç½®æ–‡ä»¶: {self.config_file}")
    
    def add_path(self, path_need_add: str, ask_create: bool = True, position: str = "prepend") -> bool:
        """
        æ·»åŠ è·¯å¾„åˆ° PATH ç¯å¢ƒå˜é‡
        
        Args:
            path_need_add: éœ€è¦æ·»åŠ çš„è·¯å¾„
            ask_create: å¦‚æœè·¯å¾„ä¸å­˜åœ¨æ˜¯å¦è¯¢é—®åˆ›å»º
            position: è·¯å¾„æ·»åŠ ä½ç½®ï¼Œ"prepend"ï¼ˆå‰ç½®ï¼‰æˆ– "append"ï¼ˆè¿½åŠ ï¼‰
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸæ·»åŠ 
        """
        try:
            # æ ‡å‡†åŒ–è·¯å¾„
            path_need_add = self._normalize_path(path_need_add)
            
            # æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨
            if not os.path.exists(path_need_add):
                if ask_create:
                    create_dir = input(f"ğŸ“ è·¯å¾„ {path_need_add} ä¸å­˜åœ¨ï¼Œæ˜¯å¦åˆ›å»ºï¼Ÿ(y/N): ").strip().lower()
                    if create_dir in ['y', 'yes']:
                        os.makedirs(path_need_add, exist_ok=True)
                        print(f"âœ… å·²åˆ›å»ºç›®å½•: {path_need_add}")
                    else:
                        print(f"âš ï¸  è·¯å¾„ {path_need_add} ä¸å­˜åœ¨ï¼Œè·³è¿‡æ·»åŠ ")
                        return False
                else:
                    print(f"âš ï¸  è·¯å¾„ {path_need_add} ä¸å­˜åœ¨ï¼Œè·³è¿‡æ·»åŠ ")
                    return False
            
            # ç¡®ä¿é…ç½®æ–‡ä»¶å­˜åœ¨
            self._create_config_if_not_exists()
            
            # è¯»å–å½“å‰é…ç½®
            with open(self.config_file, "r", encoding='utf-8') as f:
                content = f.read()
            
            # æ£€æŸ¥è·¯å¾„æ˜¯å¦å·²ç»å­˜åœ¨
            patterns = self._get_export_patterns(path_need_add)
            for pattern in patterns:
                if pattern.split('#')[0].strip() in content:
                    print(f"â„¹ï¸  è·¯å¾„ {path_need_add} å·²ç»å­˜åœ¨äºé…ç½®æ–‡ä»¶ {self.config_file} ä¸­")
                    return False
            
            # æ·»åŠ è·¯å¾„
            with open(self.config_file, "a", encoding='utf-8') as f:
                if self.shell == 'fish':
                    f.write(f'\n# Add {path_need_add} to PATH\n')
                    if position == "prepend":
                        f.write(f'set -gx PATH "{path_need_add}" $PATH\n')
                    else:
                        f.write(f'set -gx PATH $PATH "{path_need_add}"\n')
                else:
                    f.write(f'\n# Add {path_need_add} to PATH\n')
                    if position == "prepend":
                        f.write(f'export PATH="{path_need_add}:$PATH"  # Added by path manager\n')
                    else:
                        f.write(f'export PATH="$PATH:{path_need_add}"  # Added by path manager\n')
            
            print(f"âœ… æˆåŠŸæ·»åŠ è·¯å¾„: {path_need_add} åˆ°é…ç½®æ–‡ä»¶ {self.config_file}")
            print(f"ğŸ’¡ è¯·è¿è¡Œ 'source {self.config_file}' æˆ–é‡æ–°å¯åŠ¨ç»ˆç«¯ä½¿é…ç½®ç”Ÿæ•ˆ")
            
            # æ˜¾ç¤ºå½“å‰ PATH
            self.show_current_path()
            return True
            
        except Exception as e:
            print(f"âŒ æ·»åŠ è·¯å¾„æ—¶å‡ºé”™: {e}")
            return False
    
    def remove_path(self, path_to_remove: str) -> bool:
        """
        ä» PATH ä¸­ç§»é™¤è·¯å¾„
        
        Args:
            path_to_remove: éœ€è¦ç§»é™¤çš„è·¯å¾„
            
        Returns:
            bool: æ˜¯å¦æˆåŠŸç§»é™¤
        """
        try:
            if not os.path.exists(self.config_file):
                print(f"âŒ é…ç½®æ–‡ä»¶ {self.config_file} ä¸å­˜åœ¨")
                return False
            
            # æ ‡å‡†åŒ–è·¯å¾„
            path_to_remove = self._normalize_path(path_to_remove)
            
            # è¯»å–æ–‡ä»¶å†…å®¹
            with open(self.config_file, "r", encoding='utf-8') as f:
                lines = f.readlines()
            
            # æŸ¥æ‰¾å¹¶ç§»é™¤åŒ…å«æŒ‡å®šè·¯å¾„çš„è¡Œ
            original_length = len(lines)
            new_lines = []
            removed = False
            
            i = 0
            while i < len(lines):
                line = lines[i]
                line_stripped = line.split('#')[0].strip()
                
                # æ£€æŸ¥æ˜¯å¦æ˜¯è·¯å¾„ç›¸å…³çš„è¡Œ
                patterns = self._get_export_patterns(path_to_remove)
                is_path_line = any(pattern.split('#')[0].strip() == line_stripped for pattern in patterns)
                
                # æ£€æŸ¥æ˜¯å¦æ˜¯æ³¨é‡Šéƒ¨åˆ†
                is_comment_line = f"# Add {path_to_remove} to PATH" in line
                
                if is_path_line or is_comment_line:
                    removed = True
                    # è·³è¿‡è¿™ä¸€è¡Œ
                    i += 1
                    continue
                
                new_lines.append(line)
                i += 1
            
            # å¦‚æœå†…å®¹æœ‰å˜åŒ–ï¼Œåˆ™å†™å›æ–‡ä»¶
            if removed:
                with open(self.config_file, "w", encoding='utf-8') as f:
                    f.writelines(new_lines)
                print(f"âœ… æˆåŠŸç§»é™¤è·¯å¾„: {path_to_remove} ä»é…ç½®æ–‡ä»¶: {self.config_file}")
                return True
            else:
                print(f"âš ï¸  è·¯å¾„: {path_to_remove} ä¸å­˜åœ¨äºé…ç½®æ–‡ä»¶ä¸­")
                return False
                
        except Exception as e:
            print(f"âŒ ç§»é™¤è·¯å¾„æ—¶å‡ºé”™: {e}")
            return False
    
    def show_current_path(self):
        """æ˜¾ç¤ºå½“å‰ PATH è®¾ç½®"""
        print(f"\nğŸ“‹ å½“å‰ PATH ç¯å¢ƒå˜é‡:")
        current_path = os.environ.get('PATH', '')
        if not current_path:
            print("  â„¹ï¸  PATH ç¯å¢ƒå˜é‡ä¸ºç©º")
            return
            
        paths = current_path.split(':')
        for i, path in enumerate(paths, 1):
            exists = " âœ…" if os.path.exists(path) else " âŒ"
            print(f"  {i:2d}. {path}{exists}")
    
    def list_managed_paths(self):
        """åˆ—å‡ºæ‰€æœ‰ç®¡ç†çš„è·¯å¾„"""
        if not os.path.exists(self.config_file):
            print(f"âŒ é…ç½®æ–‡ä»¶ {self.config_file} ä¸å­˜åœ¨")
            return
        
        print(f"\nğŸ“ åœ¨ {self.config_file} ä¸­ç®¡ç†çš„è·¯å¾„:")
        with open(self.config_file, "r", encoding='utf-8') as f:
            lines = f.readlines()
        
        found = False
        current_section = None
        
        for line in lines:
            line = line.strip()
            if line.startswith('# Add ') and ' to PATH' in line:
                current_section = line.replace('# Add ', '').replace(' to PATH', '')
            elif line and current_section:
                if line.startswith('export PATH=') or line.startswith('set -gx PATH'):
                    print(f"  ğŸ“ {current_section}")
                    print(f"     å‘½ä»¤: {line}")
                    found = True
                    current_section = None
        
        if not found:
            print("  â„¹ï¸  æ²¡æœ‰æ‰¾åˆ°ç”±æœ¬å·¥å…·ç®¡ç†çš„è·¯å¾„")
    
    def validate_paths(self) -> List[Tuple[str, bool]]:
        """
        éªŒè¯æ‰€æœ‰ç®¡ç†çš„è·¯å¾„æ˜¯å¦å­˜åœ¨
        
        Returns:
            List[Tuple[str, bool]]: è·¯å¾„å’Œæ˜¯å¦å­˜åœ¨çš„å…ƒç»„åˆ—è¡¨
        """
        if not os.path.exists(self.config_file):
            return []
        
        results = []
        with open(self.config_file, "r", encoding='utf-8') as f:
            lines = f.readlines()
        
        current_path = None
        for line in lines:
            line = line.strip()
            if line.startswith('# Add ') and ' to PATH' in line:
                current_path = line.replace('# Add ', '').replace(' to PATH', '')
            elif line and current_path and (line.startswith('export PATH=') or line.startswith('set -gx PATH')):
                exists = os.path.exists(current_path)
                results.append((current_path, exists))
                current_path = None
        
        return results
    
    def cleanup_invalid_paths(self) -> int:
        """
        æ¸…ç†æ— æ•ˆçš„è·¯å¾„ï¼ˆä¸å­˜åœ¨çš„è·¯å¾„ï¼‰
        
        Returns:
            int: æ¸…ç†çš„è·¯å¾„æ•°é‡
        """
        invalid_paths = [path for path, exists in self.validate_paths() if not exists]
        
        if not invalid_paths:
            print("âœ… æ²¡æœ‰æ‰¾åˆ°æ— æ•ˆè·¯å¾„")
            return 0
        
        print(f"ğŸ” æ‰¾åˆ° {len(invalid_paths)} ä¸ªæ— æ•ˆè·¯å¾„:")
        for path in invalid_paths:
            print(f"  âŒ {path}")
        
        confirm = input(f"\næ˜¯å¦ç§»é™¤è¿™äº›æ— æ•ˆè·¯å¾„ï¼Ÿ(y/N): ").strip().lower()
        if confirm in ['y', 'yes']:
            removed_count = 0
            for path in invalid_paths:
                if self.remove_path(path):
                    removed_count += 1
            print(f"âœ… å·²ç§»é™¤ {removed_count} ä¸ªæ— æ•ˆè·¯å¾„")
            return removed_count
        else:
            print("âš ï¸  å·²å–æ¶ˆæ¸…ç†æ“ä½œ")
            return 0
    
    @property
    def shell(self) -> str:
        """è·å– shell ç±»å‹"""
        return self.shell_name


def main():
    """ä¸»å‡½æ•°"""
    parser = argparse.ArgumentParser(
        description="PATH ç¯å¢ƒå˜é‡ç®¡ç†å·¥å…·",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ä½¿ç”¨ç¤ºä¾‹:
  %(prog)s /usr/local/bin              # æ·»åŠ è·¯å¾„
  %(prog)s /usr/local/bin --remove     # ç§»é™¤è·¯å¾„
  %(prog)s --list                      # åˆ—å‡ºç®¡ç†çš„è·¯å¾„
  %(prog)s --show                      # æ˜¾ç¤ºå½“å‰ PATH
  %(prog)s --validate                  # éªŒè¯è·¯å¾„æœ‰æ•ˆæ€§
  %(prog)s --cleanup                   # æ¸…ç†æ— æ•ˆè·¯å¾„
  %(prog)s ~/myapp/bin --config ~/.bashrc  # æŒ‡å®šé…ç½®æ–‡ä»¶
  %(prog)s ~/myapp/bin --append        # è¿½åŠ è·¯å¾„ï¼ˆé»˜è®¤å‰ç½®ï¼‰
        """
    )
    
    parser.add_argument("path", nargs="?", help="è¦æ·»åŠ æˆ–ç§»é™¤çš„è·¯å¾„")
    parser.add_argument("--remove", action="store_true", help="ç§»é™¤è·¯å¾„è€Œä¸æ˜¯æ·»åŠ ")
    parser.add_argument("--list", action="store_true", help="åˆ—å‡ºæ‰€æœ‰ç®¡ç†çš„è·¯å¾„")
    parser.add_argument("--show", action="store_true", help="æ˜¾ç¤ºå½“å‰ PATH ç¯å¢ƒå˜é‡")
    parser.add_argument("--validate", action="store_true", help="éªŒè¯æ‰€æœ‰ç®¡ç†çš„è·¯å¾„æ˜¯å¦å­˜åœ¨")
    parser.add_argument("--cleanup", action="store_true", help="æ¸…ç†æ— æ•ˆçš„è·¯å¾„")
    parser.add_argument("--config", help="æŒ‡å®šé…ç½®æ–‡ä»¶è·¯å¾„")
    parser.add_argument("--force", action="store_true", help="ä¸è¯¢é—®ç›´æ¥åˆ›å»ºä¸å­˜åœ¨çš„ç›®å½•")
    parser.add_argument("--append", action="store_true", help="å°†è·¯å¾„è¿½åŠ åˆ° PATHï¼ˆé»˜è®¤å‰ç½®ï¼‰")
    
    args = parser.parse_args()
    
    # åˆ›å»ºè·¯å¾„ç®¡ç†å™¨
    manager = PathManager(args.config)
    print(f"ğŸ¯ ä½¿ç”¨é…ç½®æ–‡ä»¶: {manager.config_file} ({manager.shell})")
    
    # ç¡®å®šè·¯å¾„æ·»åŠ ä½ç½®
    position = "append" if args.append else "prepend"
    
    if args.list:
        manager.list_managed_paths()
    elif args.show:
        manager.show_current_path()
    elif args.validate:
        results = manager.validate_paths()
        if results:
            print(f"\nğŸ” è·¯å¾„éªŒè¯ç»“æœ:")
            for path, exists in results:
                status = "âœ… å­˜åœ¨" if exists else "âŒ ä¸å­˜åœ¨"
                print(f"  {status}: {path}")
        else:
            print("â„¹ï¸  æ²¡æœ‰æ‰¾åˆ°ç®¡ç†çš„è·¯å¾„")
    elif args.cleanup:
        manager.cleanup_invalid_paths()
    elif args.path:
        if args.remove:
            manager.remove_path(args.path)
        else:
            manager.add_path(args.path, ask_create=not args.force, position=position)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()